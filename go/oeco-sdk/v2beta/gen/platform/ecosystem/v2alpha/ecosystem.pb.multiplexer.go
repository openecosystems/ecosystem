// Code generated by protoc-gen-platform go/multiplexer-v2beta. DO NOT EDIT.
// source: platform/ecosystem/v2alpha/ecosystem.proto

package ecosystemv2alphapb

import (
	"connectrpc.com/connect"
	"errors"
	"google.golang.org/protobuf/types/known/anypb"

	"github.com/nats-io/nats.go/jetstream"
	"github.com/openecosystems/ecosystem/go/oeco-sdk/v2beta"
	"github.com/openecosystems/ecosystem/go/oeco-sdk/v2beta/bindings/nats"
	"github.com/openecosystems/ecosystem/go/oeco-sdk/v2beta/bindings/opentelemetry"
	"github.com/openecosystems/ecosystem/go/oeco-sdk/v2beta/bindings/protovalidate"
	optionv2pb "github.com/openecosystems/ecosystem/go/oeco-sdk/v2beta/gen/platform/options/v2"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/protobuf/proto"

	"github.com/openecosystems/ecosystem/go/oeco-sdk/v2beta/gen/platform/spec/v2"

	_ "github.com/openecosystems/ecosystem/go/oeco-sdk/v2beta/gen/platform/spec/v2"
	_ "google.golang.org/protobuf/types/known/timestamppb"

	"context"
)

// EcosystemServiceHandler is the domain level implementation of the server API for mutations of the EcosystemService service
type EcosystemServiceHandler struct{}

func (s *EcosystemServiceHandler) GetCreateEcosystemConfiguration() *natsnodev1.ListenerConfiguration {

	return &natsnodev1.ListenerConfiguration{
		Entity:     &EcosystemSpecEntity{},
		Procedure:  "CreateEcosystem",
		CQRS:       optionv2pb.CQRSType_CQRS_TYPE_MUTATION_CREATE,
		Topic:      CommandDataEcosystemTopic,
		StreamType: natsnodev1.NewInboundStream(),
		JetstreamConfiguration: &jetstream.ConsumerConfig{
			Durable:       "ecosystem-ecosystem-createEcosystem",
			AckPolicy:     jetstream.AckExplicitPolicy,
			MemoryStorage: false,
		},
	}
}

func (s *EcosystemServiceHandler) CreateEcosystem(ctx context.Context, req *connect.Request[CreateEcosystemRequest]) (*connect.Response[CreateEcosystemResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer

	parentSpanCtx := trace.SpanContextFromContext(ctx)
	ctx = trace.ContextWithRemoteSpanContext(ctx, parentSpanCtx)

	spec, ok := ctx.Value(sdkv2betalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "create-ecosystem-request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&CreateEcosystemResponse{}) {
			return nil, sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(validationCtx, "create-ecosystem-event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	config := s.GetCreateEcosystemConfiguration()
	reply, serr := natsnodev1.Bound.MultiplexCommandSync(handlerCtx, spec, &natsnodev1.SpecCommand{
		Request:        req.Msg,
		Stream:         config.StreamType,
		Procedure:      config.Procedure,
		CommandName:    "",
		CommandTopic:   config.Topic,
		EntityTypeName: config.Entity.TypeName(),
	})
	if serr != nil {
		return nil, serr
	}

	var s2 specv2pb.Spec
	err := proto.Unmarshal(reply.Data, &s2)
	if err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	if s2.SpecError != nil {
		return nil, sdkv2betalib.NewSpecErrorFromStatus(s2.SpecError)
	}

	if s2.SpecData == nil || s2.SpecData.Data == nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("The response did not contain any spec data response. Investigate. Bug."))
	}

	var response CreateEcosystemResponse
	if err = anypb.UnmarshalTo(s2.SpecData.Data, &response, proto.UnmarshalOptions{}); err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	handlerSpan.End()

	return connect.NewResponse(&response), nil

}

func (s *EcosystemServiceHandler) GetUpdateEcosystemConfiguration() *natsnodev1.ListenerConfiguration {

	return &natsnodev1.ListenerConfiguration{
		Entity:     &EcosystemSpecEntity{},
		Procedure:  "UpdateEcosystem",
		CQRS:       optionv2pb.CQRSType_CQRS_TYPE_MUTATION_UPDATE,
		Topic:      CommandDataEcosystemTopic,
		StreamType: natsnodev1.NewInboundStream(),
		JetstreamConfiguration: &jetstream.ConsumerConfig{
			Durable:       "ecosystem-ecosystem-updateEcosystem",
			AckPolicy:     jetstream.AckExplicitPolicy,
			MemoryStorage: false,
		},
	}
}

func (s *EcosystemServiceHandler) UpdateEcosystem(ctx context.Context, req *connect.Request[UpdateEcosystemRequest]) (*connect.Response[UpdateEcosystemResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer

	parentSpanCtx := trace.SpanContextFromContext(ctx)
	ctx = trace.ContextWithRemoteSpanContext(ctx, parentSpanCtx)

	spec, ok := ctx.Value(sdkv2betalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "update-ecosystem-request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&UpdateEcosystemResponse{}) {
			return nil, sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(validationCtx, "update-ecosystem-event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	config := s.GetUpdateEcosystemConfiguration()
	reply, serr := natsnodev1.Bound.MultiplexCommandSync(handlerCtx, spec, &natsnodev1.SpecCommand{
		Request:        req.Msg,
		Stream:         config.StreamType,
		Procedure:      config.Procedure,
		CommandName:    "",
		CommandTopic:   config.Topic,
		EntityTypeName: config.Entity.TypeName(),
	})
	if serr != nil {
		return nil, serr
	}

	var s2 specv2pb.Spec
	err := proto.Unmarshal(reply.Data, &s2)
	if err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	if s2.SpecError != nil {
		return nil, sdkv2betalib.NewSpecErrorFromStatus(s2.SpecError)
	}

	if s2.SpecData == nil || s2.SpecData.Data == nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("The response did not contain any spec data response. Investigate. Bug."))
	}

	var response UpdateEcosystemResponse
	if err = anypb.UnmarshalTo(s2.SpecData.Data, &response, proto.UnmarshalOptions{}); err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	handlerSpan.End()

	return connect.NewResponse(&response), nil

}

func (s *EcosystemServiceHandler) GetDeleteEcosystemConfiguration() *natsnodev1.ListenerConfiguration {

	return &natsnodev1.ListenerConfiguration{
		Entity:     &EcosystemSpecEntity{},
		Procedure:  "DeleteEcosystem",
		CQRS:       optionv2pb.CQRSType_CQRS_TYPE_MUTATION_DELETE,
		Topic:      CommandDataEcosystemTopic,
		StreamType: natsnodev1.NewInboundStream(),
		JetstreamConfiguration: &jetstream.ConsumerConfig{
			Durable:       "ecosystem-ecosystem-deleteEcosystem",
			AckPolicy:     jetstream.AckExplicitPolicy,
			MemoryStorage: false,
		},
	}
}

func (s *EcosystemServiceHandler) DeleteEcosystem(ctx context.Context, req *connect.Request[DeleteEcosystemRequest]) (*connect.Response[DeleteEcosystemResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer

	parentSpanCtx := trace.SpanContextFromContext(ctx)
	ctx = trace.ContextWithRemoteSpanContext(ctx, parentSpanCtx)

	spec, ok := ctx.Value(sdkv2betalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "delete-ecosystem-request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&DeleteEcosystemResponse{}) {
			return nil, sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(validationCtx, "delete-ecosystem-event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	config := s.GetDeleteEcosystemConfiguration()
	reply, serr := natsnodev1.Bound.MultiplexCommandSync(handlerCtx, spec, &natsnodev1.SpecCommand{
		Request:        req.Msg,
		Stream:         config.StreamType,
		Procedure:      config.Procedure,
		CommandName:    "",
		CommandTopic:   config.Topic,
		EntityTypeName: config.Entity.TypeName(),
	})
	if serr != nil {
		return nil, serr
	}

	var s2 specv2pb.Spec
	err := proto.Unmarshal(reply.Data, &s2)
	if err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	if s2.SpecError != nil {
		return nil, sdkv2betalib.NewSpecErrorFromStatus(s2.SpecError)
	}

	if s2.SpecData == nil || s2.SpecData.Data == nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("The response did not contain any spec data response. Investigate. Bug."))
	}

	var response DeleteEcosystemResponse
	if err = anypb.UnmarshalTo(s2.SpecData.Data, &response, proto.UnmarshalOptions{}); err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	handlerSpan.End()

	return connect.NewResponse(&response), nil

}

func (s *EcosystemServiceHandler) GetListEcosystemsConfiguration() *natsnodev1.ListenerConfiguration {

	return &natsnodev1.ListenerConfiguration{
		Entity:     &EcosystemSpecEntity{},
		Procedure:  "ListEcosystems",
		CQRS:       optionv2pb.CQRSType_CQRS_TYPE_QUERY_LIST,
		Topic:      EventDataEcosystemTopic,
		StreamType: natsnodev1.NewInboundStream(),
		JetstreamConfiguration: &jetstream.ConsumerConfig{
			Durable:       "ecosystem-ecosystem-listEcosystems",
			AckPolicy:     jetstream.AckExplicitPolicy,
			MemoryStorage: false,
		},
	}
}

func (s *EcosystemServiceHandler) ListEcosystems(ctx context.Context, req *connect.Request[ListEcosystemsRequest]) (*connect.Response[ListEcosystemsResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer

	parentSpanCtx := trace.SpanContextFromContext(ctx)
	ctx = trace.ContextWithRemoteSpanContext(ctx, parentSpanCtx)

	spec, ok := ctx.Value(sdkv2betalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "list-ecosystems-request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&ListEcosystemsResponse{}) {
			return nil, sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(validationCtx, "list-ecosystems-event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	config := s.GetListEcosystemsConfiguration()
	reply, serr := natsnodev1.Bound.MultiplexEventSync(handlerCtx, spec, &natsnodev1.SpecEvent{
		Request:        req.Msg,
		Stream:         config.StreamType,
		Procedure:      config.Procedure,
		EventName:      "",
		EventTopic:     config.Topic,
		EntityTypeName: config.Entity.TypeName(),
	})
	if serr != nil {
		return nil, serr
	}

	var s2 specv2pb.Spec
	err := proto.Unmarshal(reply.Data, &s2)
	if err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	if s2.SpecError != nil {
		return nil, sdkv2betalib.NewSpecErrorFromStatus(s2.SpecError)
	}

	if s2.SpecData == nil || s2.SpecData.Data == nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("The response did not contain any spec data response. Investigate. Bug."))
	}

	var response ListEcosystemsResponse
	if err = anypb.UnmarshalTo(s2.SpecData.Data, &response, proto.UnmarshalOptions{}); err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	handlerSpan.End()

	return connect.NewResponse(&response), nil

}

func (s *EcosystemServiceHandler) GetGetEcosystemConfiguration() *natsnodev1.ListenerConfiguration {

	return &natsnodev1.ListenerConfiguration{
		Entity:     &EcosystemSpecEntity{},
		Procedure:  "GetEcosystem",
		CQRS:       optionv2pb.CQRSType_CQRS_TYPE_QUERY_GET,
		Topic:      EventDataEcosystemTopic,
		StreamType: natsnodev1.NewInboundStream(),
		JetstreamConfiguration: &jetstream.ConsumerConfig{
			Durable:       "ecosystem-ecosystem-getEcosystem",
			AckPolicy:     jetstream.AckExplicitPolicy,
			MemoryStorage: false,
		},
	}
}

func (s *EcosystemServiceHandler) GetEcosystem(ctx context.Context, req *connect.Request[GetEcosystemRequest]) (*connect.Response[GetEcosystemResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer

	parentSpanCtx := trace.SpanContextFromContext(ctx)
	ctx = trace.ContextWithRemoteSpanContext(ctx, parentSpanCtx)

	spec, ok := ctx.Value(sdkv2betalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "get-ecosystem-request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&GetEcosystemResponse{}) {
			return nil, sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(validationCtx, "get-ecosystem-event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	config := s.GetGetEcosystemConfiguration()
	reply, serr := natsnodev1.Bound.MultiplexEventSync(handlerCtx, spec, &natsnodev1.SpecEvent{
		Request:        req.Msg,
		Stream:         config.StreamType,
		Procedure:      config.Procedure,
		EventName:      "",
		EventTopic:     config.Topic,
		EntityTypeName: config.Entity.TypeName(),
	})
	if serr != nil {
		return nil, serr
	}

	var s2 specv2pb.Spec
	err := proto.Unmarshal(reply.Data, &s2)
	if err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	if s2.SpecError != nil {
		return nil, sdkv2betalib.NewSpecErrorFromStatus(s2.SpecError)
	}

	if s2.SpecData == nil || s2.SpecData.Data == nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("The response did not contain any spec data response. Investigate. Bug."))
	}

	var response GetEcosystemResponse
	if err = anypb.UnmarshalTo(s2.SpecData.Data, &response, proto.UnmarshalOptions{}); err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	handlerSpan.End()

	return connect.NewResponse(&response), nil

}
