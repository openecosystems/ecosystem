// Package lists provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package sendgridlistv1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// ContactDetails defines model for ContactDetails.
type ContactDetails struct {
	Metadata            *SelfMetadata           `json:"_metadata,omitempty"`
	AddressLine1        *string                 `json:"address_line_1,omitempty"`
	AddressLine2        *string                 `json:"address_line_2,omitempty"`
	AlternateEmails     *[]openapi_types.Email  `json:"alternate_emails"`
	AnonymousId         *string                 `json:"anonymous_id,omitempty"`
	City                *string                 `json:"city,omitempty"`
	Country             *string                 `json:"country,omitempty"`
	CreatedAt           time.Time               `json:"created_at"`
	CustomFields        *map[string]interface{} `json:"custom_fields,omitempty"`
	Email               *openapi_types.Email    `json:"email,omitempty"`
	ExternalId          *string                 `json:"external_id,omitempty"`
	Facebook            *string                 `json:"facebook,omitempty"`
	FirstName           *string                 `json:"first_name,omitempty"`
	Id                  openapi_types.UUID      `json:"id"`
	LastName            *string                 `json:"last_name,omitempty"`
	Line                *string                 `json:"line,omitempty"`
	ListIds             []openapi_types.UUID    `json:"list_ids"`
	PhoneNumber         *string                 `json:"phone_number,omitempty"`
	PhoneNumberId       *string                 `json:"phone_number_id,omitempty"`
	PostalCode          *string                 `json:"postal_code,omitempty"`
	SegmentIds          *[]openapi_types.UUID   `json:"segment_ids,omitempty"`
	StateProvinceRegion *string                 `json:"state_province_region,omitempty"`
	UniqueName          *string                 `json:"unique_name,omitempty"`
	UpdatedAt           time.Time               `json:"updated_at"`
	Whatsapp            *string                 `json:"whatsapp,omitempty"`
}

// Error defines model for Error.
type Error struct {
	ErrorId   *string `json:"error_id,omitempty"`
	Field     *string `json:"field,omitempty"`
	Message   string  `json:"message"`
	Parameter *string `json:"parameter,omitempty"`
}

// List defines model for List.
type List struct {
	Metadata *SelfMetadata `json:"_metadata,omitempty"`

	// ContactCount The number of contacts currently stored on the list.
	ContactCount *int `json:"contact_count,omitempty"`

	// Id The generated ID for your list.
	Id *string `json:"id,omitempty"`

	// Name The name you gave your list.
	Name *string `json:"name,omitempty"`
}

// Metadata defines model for Metadata.
type Metadata struct {
	// Count The number of items in the entire list, i.e., across all pages.
	Count *float32 `json:"count,omitempty"`

	// Next The URL of the next page of results. If this field isn't present, you're at the end of the list.
	Next *string `json:"next,omitempty"`

	// Prev The URL of the previous page of results. If this field isn't present, you're at the start of the list.
	Prev *string `json:"prev,omitempty"`

	// Self The URL of the current page of results.
	Self *string `json:"self,omitempty"`
}

// SelfMetadata defines model for SelfMetadata.
type SelfMetadata struct {
	// Self A link to this object.
	Self *string `json:"self,omitempty"`
}

// ListMarketingListParams defines parameters for ListMarketingList.
type ListMarketingListParams struct {
	// PageSize Maximum number of elements to return. Defaults to 100, returns 1000 max
	PageSize  *float32 `form:"page_size,omitempty" json:"page_size,omitempty"`
	PageToken *string  `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// CreateMarketingListJSONBody defines parameters for CreateMarketingList.
type CreateMarketingListJSONBody struct {
	// Name Your name for your list
	Name string `json:"name"`
}

// DeleteMarketingListParams defines parameters for DeleteMarketingList.
type DeleteMarketingListParams struct {
	// DeleteContacts Flag indicates that all contacts on the list are also to be deleted.
	DeleteContacts *bool `form:"delete_contacts,omitempty" json:"delete_contacts,omitempty"`
}

// GetMarketingListParams defines parameters for GetMarketingList.
type GetMarketingListParams struct {
	// ContactSample Setting this parameter to the true  will cause the contact_sample to be returned
	ContactSample *bool `form:"contact_sample,omitempty" json:"contact_sample,omitempty"`
}

// UpdateMarketingListJSONBody defines parameters for UpdateMarketingList.
type UpdateMarketingListJSONBody struct {
	// Name Your name for your list.
	Name *string `json:"name,omitempty"`
}

// DeleteContactParams defines parameters for DeleteContact.
type DeleteContactParams struct {
	// ContactIds Comma separated list of contact IDs that you want to remove from the specified contacts list.
	ContactIds string `form:"contact_ids" json:"contact_ids"`
}

// CreateMarketingListJSONRequestBody defines body for CreateMarketingList for application/json ContentType.
type CreateMarketingListJSONRequestBody CreateMarketingListJSONBody

// UpdateMarketingListJSONRequestBody defines body for UpdateMarketingList for application/json ContentType.
type UpdateMarketingListJSONRequestBody UpdateMarketingListJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListMarketingList request
	ListMarketingList(ctx context.Context, params *ListMarketingListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMarketingListWithBody request with any body
	CreateMarketingListWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMarketingList(ctx context.Context, body CreateMarketingListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMarketingList request
	DeleteMarketingList(ctx context.Context, id string, params *DeleteMarketingListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMarketingList request
	GetMarketingList(ctx context.Context, id string, params *GetMarketingListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMarketingListWithBody request with any body
	UpdateMarketingListWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMarketingList(ctx context.Context, id string, body UpdateMarketingListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteContact request
	DeleteContact(ctx context.Context, id string, params *DeleteContactParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContactCount request
	ListContactCount(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListMarketingList(ctx context.Context, params *ListMarketingListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMarketingListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMarketingListWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMarketingListRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMarketingList(ctx context.Context, body CreateMarketingListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMarketingListRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMarketingList(ctx context.Context, id string, params *DeleteMarketingListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMarketingListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMarketingList(ctx context.Context, id string, params *GetMarketingListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMarketingListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMarketingListWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMarketingListRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMarketingList(ctx context.Context, id string, body UpdateMarketingListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMarketingListRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteContact(ctx context.Context, id string, params *DeleteContactParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteContactRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContactCount(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContactCountRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListMarketingListRequest generates requests for ListMarketingList
func NewListMarketingListRequest(server string, params *ListMarketingListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.PageToken != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMarketingListRequest calls the generic CreateMarketingList builder with application/json body
func NewCreateMarketingListRequest(server string, body CreateMarketingListJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMarketingListRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMarketingListRequestWithBody generates requests for CreateMarketingList with any type of body
func NewCreateMarketingListRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMarketingListRequest generates requests for DeleteMarketingList
func NewDeleteMarketingListRequest(server string, id string, params *DeleteMarketingListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteContacts != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_contacts", runtime.ParamLocationQuery, *params.DeleteContacts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMarketingListRequest generates requests for GetMarketingList
func NewGetMarketingListRequest(server string, id string, params *GetMarketingListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContactSample != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contact_sample", runtime.ParamLocationQuery, *params.ContactSample); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMarketingListRequest calls the generic UpdateMarketingList builder with application/json body
func NewUpdateMarketingListRequest(server string, id string, body UpdateMarketingListJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMarketingListRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateMarketingListRequestWithBody generates requests for UpdateMarketingList with any type of body
func NewUpdateMarketingListRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteContactRequest generates requests for DeleteContact
func NewDeleteContactRequest(server string, id string, params *DeleteContactParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/lists/%s/contacts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contact_ids", runtime.ParamLocationQuery, params.ContactIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListContactCountRequest generates requests for ListContactCount
func NewListContactCountRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/lists/%s/contacts/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListMarketingListWithResponse request
	ListMarketingListWithResponse(ctx context.Context, params *ListMarketingListParams, reqEditors ...RequestEditorFn) (*ListMarketingListResponse, error)

	// CreateMarketingListWithBodyWithResponse request with any body
	CreateMarketingListWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMarketingListResponse, error)

	CreateMarketingListWithResponse(ctx context.Context, body CreateMarketingListJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMarketingListResponse, error)

	// DeleteMarketingListWithResponse request
	DeleteMarketingListWithResponse(ctx context.Context, id string, params *DeleteMarketingListParams, reqEditors ...RequestEditorFn) (*DeleteMarketingListResponse, error)

	// GetMarketingListWithResponse request
	GetMarketingListWithResponse(ctx context.Context, id string, params *GetMarketingListParams, reqEditors ...RequestEditorFn) (*GetMarketingListResponse, error)

	// UpdateMarketingListWithBodyWithResponse request with any body
	UpdateMarketingListWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMarketingListResponse, error)

	UpdateMarketingListWithResponse(ctx context.Context, id string, body UpdateMarketingListJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMarketingListResponse, error)

	// DeleteContactWithResponse request
	DeleteContactWithResponse(ctx context.Context, id string, params *DeleteContactParams, reqEditors ...RequestEditorFn) (*DeleteContactResponse, error)

	// ListContactCountWithResponse request
	ListContactCountWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ListContactCountResponse, error)
}

type ListMarketingListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Metadata *Metadata `json:"_metadata,omitempty"`
		Result   *[]List   `json:"result,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMarketingListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMarketingListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMarketingListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *List
	JSON400      *struct {
		Errors *[]Error `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateMarketingListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMarketingListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMarketingListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// JobId job_id of the async job
		JobId *string `json:"job_id,omitempty"`
	}
	JSON204 *string
	JSON404 *struct {
		Errors []map[string]interface{} `json:"errors"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteMarketingListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMarketingListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMarketingListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Metadata *SelfMetadata `json:"_metadata,omitempty"`

		// ContactCount The number of contacts currently stored on the list.
		ContactCount  *int            `json:"contact_count,omitempty"`
		ContactSample *ContactDetails `json:"contact_sample,omitempty"`

		// Id The generated ID for your list.
		Id *string `json:"id,omitempty"`

		// Name The name you gave your list.
		Name *string `json:"name,omitempty"`
	}
	JSON404 *[]Error
}

// Status returns HTTPResponse.Status
func (r GetMarketingListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMarketingListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMarketingListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *List
	JSON400      *struct {
		Errors *[]Error `json:"errors,omitempty"`
	}
	JSON404 *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r UpdateMarketingListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMarketingListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// JobId job_id of the async job
		JobId *string `json:"job_id,omitempty"`
	}
	JSON400 *Error
	JSON404 *interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContactCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		BillableCount *int `json:"billable_count,omitempty"`
		ContactCount  *int `json:"contact_count,omitempty"`
	}
	JSON404 *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ListContactCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContactCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListMarketingListWithResponse request returning *ListMarketingListResponse
func (c *ClientWithResponses) ListMarketingListWithResponse(ctx context.Context, params *ListMarketingListParams, reqEditors ...RequestEditorFn) (*ListMarketingListResponse, error) {
	rsp, err := c.ListMarketingList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMarketingListResponse(rsp)
}

// CreateMarketingListWithBodyWithResponse request with arbitrary body returning *CreateMarketingListResponse
func (c *ClientWithResponses) CreateMarketingListWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMarketingListResponse, error) {
	rsp, err := c.CreateMarketingListWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMarketingListResponse(rsp)
}

func (c *ClientWithResponses) CreateMarketingListWithResponse(ctx context.Context, body CreateMarketingListJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMarketingListResponse, error) {
	rsp, err := c.CreateMarketingList(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMarketingListResponse(rsp)
}

// DeleteMarketingListWithResponse request returning *DeleteMarketingListResponse
func (c *ClientWithResponses) DeleteMarketingListWithResponse(ctx context.Context, id string, params *DeleteMarketingListParams, reqEditors ...RequestEditorFn) (*DeleteMarketingListResponse, error) {
	rsp, err := c.DeleteMarketingList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMarketingListResponse(rsp)
}

// GetMarketingListWithResponse request returning *GetMarketingListResponse
func (c *ClientWithResponses) GetMarketingListWithResponse(ctx context.Context, id string, params *GetMarketingListParams, reqEditors ...RequestEditorFn) (*GetMarketingListResponse, error) {
	rsp, err := c.GetMarketingList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMarketingListResponse(rsp)
}

// UpdateMarketingListWithBodyWithResponse request with arbitrary body returning *UpdateMarketingListResponse
func (c *ClientWithResponses) UpdateMarketingListWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMarketingListResponse, error) {
	rsp, err := c.UpdateMarketingListWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMarketingListResponse(rsp)
}

func (c *ClientWithResponses) UpdateMarketingListWithResponse(ctx context.Context, id string, body UpdateMarketingListJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMarketingListResponse, error) {
	rsp, err := c.UpdateMarketingList(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMarketingListResponse(rsp)
}

// DeleteContactWithResponse request returning *DeleteContactResponse
func (c *ClientWithResponses) DeleteContactWithResponse(ctx context.Context, id string, params *DeleteContactParams, reqEditors ...RequestEditorFn) (*DeleteContactResponse, error) {
	rsp, err := c.DeleteContact(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContactResponse(rsp)
}

// ListContactCountWithResponse request returning *ListContactCountResponse
func (c *ClientWithResponses) ListContactCountWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ListContactCountResponse, error) {
	rsp, err := c.ListContactCount(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContactCountResponse(rsp)
}

// ParseListMarketingListResponse parses an HTTP response from a ListMarketingListWithResponse call
func ParseListMarketingListResponse(rsp *http.Response) (*ListMarketingListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMarketingListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Metadata *Metadata `json:"_metadata,omitempty"`
			Result   *[]List   `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ParseCreateMarketingListResponse parses an HTTP response from a CreateMarketingListWithResponse call
func ParseCreateMarketingListResponse(rsp *http.Response) (*CreateMarketingListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMarketingListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest List
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]Error `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteMarketingListResponse parses an HTTP response from a DeleteMarketingListWithResponse call
func ParseDeleteMarketingListResponse(rsp *http.Response) (*DeleteMarketingListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMarketingListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// JobId job_id of the async job
			JobId *string `json:"job_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors []map[string]interface{} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMarketingListResponse parses an HTTP response from a GetMarketingListWithResponse call
func ParseGetMarketingListResponse(rsp *http.Response) (*GetMarketingListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMarketingListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Metadata *SelfMetadata `json:"_metadata,omitempty"`

			// ContactCount The number of contacts currently stored on the list.
			ContactCount  *int            `json:"contact_count,omitempty"`
			ContactSample *ContactDetails `json:"contact_sample,omitempty"`

			// Id The generated ID for your list.
			Id *string `json:"id,omitempty"`

			// Name The name you gave your list.
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest []Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateMarketingListResponse parses an HTTP response from a UpdateMarketingListWithResponse call
func ParseUpdateMarketingListResponse(rsp *http.Response) (*UpdateMarketingListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMarketingListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest List
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]Error `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteContactResponse parses an HTTP response from a DeleteContactWithResponse call
func ParseDeleteContactResponse(rsp *http.Response) (*DeleteContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// JobId job_id of the async job
			JobId *string `json:"job_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListContactCountResponse parses an HTTP response from a ListContactCountWithResponse call
func ParseListContactCountResponse(rsp *http.Response) (*ListContactCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContactCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			BillableCount *int `json:"billable_count,omitempty"`
			ContactCount  *int `json:"contact_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{
	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
