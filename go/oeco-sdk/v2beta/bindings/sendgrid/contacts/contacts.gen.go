// Package contacts provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package sendgridcontactsv1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for FileType.
const (
	FileTypeCsv  FileType = "csv"
	FileTypeJson FileType = "json"
)

// Defines values for FileType1.
const (
	FileType1Csv FileType1 = "csv"
)

// Defines values for IdentifierType.
const (
	ANONYMOUSID   IdentifierType = "ANONYMOUSID"
	EMAIL         IdentifierType = "EMAIL"
	EXTERNALID    IdentifierType = "EXTERNALID"
	PHONENUMBERID IdentifierType = "PHONENUMBERID"
)

// Defines values for IdentifierType1.
const (
	AnonymousId   IdentifierType1 = "anonymous_id"
	Email         IdentifierType1 = "email"
	ExternalId    IdentifierType1 = "external_id"
	PhoneNumberId IdentifierType1 = "phone_number_id"
)

// Defines values for Status.
const (
	Failure Status = "failure"
	Pending Status = "pending"
	Ready   Status = "ready"
)

// ContactDetails3 defines model for ContactDetails3.
type ContactDetails3 struct {
	Metadata            *SelfMetadata           `json:"_metadata,omitempty"`
	AddressLine1        *string                 `json:"address_line_1,omitempty"`
	AddressLine2        *string                 `json:"address_line_2,omitempty"`
	AlternateEmails     *[]string               `json:"alternate_emails,omitempty"`
	AnonymousId         *string                 `json:"anonymous_id,omitempty"`
	City                *string                 `json:"city,omitempty"`
	Country             *string                 `json:"country,omitempty"`
	CreatedAt           string                  `json:"created_at"`
	CustomFields        *map[string]interface{} `json:"custom_fields,omitempty"`
	Email               *string                 `json:"email,omitempty"`
	ExternalId          *string                 `json:"external_id,omitempty"`
	Facebook            *string                 `json:"facebook,omitempty"`
	FirstName           *string                 `json:"first_name,omitempty"`
	Id                  string                  `json:"id"`
	LastName            *string                 `json:"last_name,omitempty"`
	Line                *string                 `json:"line,omitempty"`
	ListIds             []string                `json:"list_ids"`
	PhoneNumber         *string                 `json:"phone_number,omitempty"`
	PhoneNumberId       *string                 `json:"phone_number_id,omitempty"`
	PostalCode          *string                 `json:"postal_code,omitempty"`
	SegmentIds          []string                `json:"segment_ids"`
	StateProvinceRegion *string                 `json:"state_province_region,omitempty"`
	UniqueName          *string                 `json:"unique_name,omitempty"`
	UpdatedAt           string                  `json:"updated_at"`
	Whatsapp            *string                 `json:"whatsapp,omitempty"`
}

// ContactExport defines model for ContactExport.
type ContactExport struct {
	Metadata *Metadata `json:"_metadata,omitempty"`

	// CompletedAt The ISO8601 timestamp when the export was completed.
	CompletedAt *string `json:"completed_at,omitempty"`

	// ContactCount The total number of exported contacts.
	ContactCount *int `json:"contact_count,omitempty"`

	// CreatedAt The ISO8601 timestamp when the export was begun.
	CreatedAt string `json:"created_at"`

	// ExpiresAt The ISO8601 timestamp when the exported file on S3 will expire.
	ExpiresAt string `json:"expires_at"`
	Id        string `json:"id"`

	// Message A human readable message if the status is `failure`.
	Message *string `json:"message,omitempty"`
	Status  Status  `json:"status"`

	// UpdatedAt The ISO8601 timestamp when the export was updated.
	UpdatedAt string `json:"updated_at"`

	// Urls One or more download URLs for the contact file if the status is `ready`.
	Urls *[]string `json:"urls,omitempty"`
}

// ContactImport defines model for ContactImport.
type ContactImport struct {
	// FinishedAt The ISO8601 timestamp when the job was finished.
	FinishedAt *string `json:"finished_at,omitempty"`

	// Id The job ID.
	Id *string `json:"id,omitempty"`

	// JobType The job type. Allowed values: `upsert`, or `delete`.
	JobType *string `json:"job_type,omitempty"`

	// Results Result map of the import job.
	Results *struct {
		// CreatedCount Created contact count from the import.
		CreatedCount *float32 `json:"created_count,omitempty"`

		// DeletedCount Count of deleted contacts that resulted in error.
		DeletedCount *float32 `json:"deleted_count,omitempty"`

		// ErroredCount Count of imported contacts that resulted in error.
		ErroredCount *float32 `json:"errored_count,omitempty"`

		// ErrorsUrl The download URL of the file which provides information about any errors.
		ErrorsUrl *string `json:"errors_url,omitempty"`

		// RequestedCount Requested contact count from the import.
		RequestedCount *float32 `json:"requested_count,omitempty"`

		// UpdatedCount Updated contact count from the import.
		UpdatedCount *float32 `json:"updated_count,omitempty"`
	} `json:"results,omitempty"`

	// StartedAt The ISO8601 timestamp when the job was created.
	StartedAt *string `json:"started_at,omitempty"`

	// Status The job state. Allowed values: `pending`, `completed`, `errored`, or `failed`.
	Status *string `json:"status,omitempty"`
}

// ContactRequest defines model for ContactRequest.
type ContactRequest struct {
	// AddressLine1 The first line of the address.
	AddressLine1 *string `json:"address_line_1,omitempty"`

	// AddressLine2 An optional second line for the address.
	AddressLine2 *string `json:"address_line_2,omitempty"`

	// AlternateEmails Additional emails associated with the contact.
	AlternateEmails *[]string `json:"alternate_emails,omitempty"`

	// AnonymousId The contact's Anonymous ID.
	AnonymousId *string `json:"anonymous_id,omitempty"`

	// City The contact's city.
	City *string `json:"city,omitempty"`

	// Country The contact's country. Can be a full name or an abbreviation.
	Country *string `json:"country,omitempty"`

	// CustomFields An object of custom field IDs and the values you want to associate with those custom fields. You can retrieve the IDs of your custom fields from the [Get All Field Definitions endpoint](https://docs.sendgrid.com/api-reference/custom-fields/get-all-field-definitions).
	CustomFields *struct {
		// W1 The properties in this object are made up of a key (the custom field ID) and value you want associated with that custom field. For example `{"w1": "coffee"}`.
		W1 *string `json:"w1,omitempty"`
	} `json:"custom_fields,omitempty"`

	// Email The contact's primary email. This is required to be a valid email.
	Email *string `json:"email,omitempty"`

	// ExternalId The contact's External ID.
	ExternalId *string `json:"external_id,omitempty"`

	// FirstName The contact's personal name.
	FirstName *string `json:"first_name,omitempty"`

	// LastName The contact's family name.
	LastName *string `json:"last_name,omitempty"`

	// PhoneNumberId The contact's Phone Number ID. This must be a valid phone number.
	PhoneNumberId *string `json:"phone_number_id,omitempty"`

	// PostalCode The contact's ZIP code or other postal code.
	PostalCode *string `json:"postal_code,omitempty"`

	// StateProvinceRegion The contact's state, province, or region.
	StateProvinceRegion *string `json:"state_province_region,omitempty"`
}

// ContactsError defines model for ContactsError.
type ContactsError struct {
	ErrorId   *string `json:"error_id,omitempty"`
	Field     *string `json:"field,omitempty"`
	Message   string  `json:"message"`
	Parameter *string `json:"parameter,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Errors *[]struct {
		// Field When applicable, this property value will be the field that generated the error.
		Field *string `json:"field"`

		// Help When applicable, this property value will be helper text or a link to documentation to help you troubleshoot the error.
		Help *map[string]interface{} `json:"help,omitempty"`

		// Message An error message.
		Message *string `json:"message,omitempty"`
	} `json:"errors,omitempty"`

	// Id When applicable, this property value will be an error ID.
	Id *string `json:"id,omitempty"`
}

// FileType defines model for FileType.
type FileType string

// FileType1 defines model for FileType1.
type FileType1 string

// IdentifierType defines model for IdentifierType.
type IdentifierType string

// IdentifierType1 defines model for IdentifierType1.
type IdentifierType1 string

// Metadata defines model for Metadata.
type Metadata struct {
	// Count The number of items in the entire list, i.e., across all pages.
	Count *float32 `json:"count,omitempty"`

	// Next The URL of the next page of results. If this field isn't present, you're at the end of the list.
	Next *string `json:"next,omitempty"`

	// Prev The URL of the previous page of results. If this field isn't present, you're at the start of the list.
	Prev *string `json:"prev,omitempty"`

	// Self The URL of the current page of results.
	Self *string `json:"self,omitempty"`
}

// SelfMetadata defines model for SelfMetadata.
type SelfMetadata struct {
	// Self A link to this object.
	Self *string `json:"self,omitempty"`
}

// Status defines model for Status.
type Status string

// MarketingContacts401 defines model for MarketingContacts401.
type MarketingContacts401 = ErrorResponse

// MarketingContacts403 defines model for MarketingContacts403.
type MarketingContacts403 = ErrorResponse

// MarketingContacts404 defines model for MarketingContacts404.
type MarketingContacts404 = ErrorResponse

// MarketingContacts500 defines model for MarketingContacts500.
type MarketingContacts500 struct {
	Errors *[]struct {
		Message *string `json:"message,omitempty"`
	} `json:"errors,omitempty"`
}

// DeleteContactParams defines parameters for DeleteContact.
type DeleteContactParams struct {
	// DeleteAllContacts Must be set to `"true"` to delete all contacts.
	DeleteAllContacts *string `form:"delete_all_contacts,omitempty" json:"delete_all_contacts,omitempty"`

	// Ids A comma-separated list of contact IDs.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`
}

// UpdateContactJSONBody defines parameters for UpdateContact.
type UpdateContactJSONBody struct {
	// Contacts One or more contacts objects that you intend to upsert. Each contact needs to include at least one of `email`, `phone_number_id`, `external_id`, or `anonymous_id` as an identifier.
	Contacts []ContactRequest `json:"contacts"`

	// ListIds An array of List ID strings that this contact will be added to.
	ListIds *[]openapi_types.UUID `json:"list_ids,omitempty"`
}

// ListBatchedContactJSONBody defines parameters for ListBatchedContact.
type ListBatchedContactJSONBody struct {
	Ids []string `json:"ids"`
}

// ExportContactJSONBody defines parameters for ExportContact.
type ExportContactJSONBody struct {
	FileType *FileType `json:"file_type,omitempty"`

	// ListIds IDs of the contact lists you want to export.
	ListIds *[]openapi_types.UUID `json:"list_ids,omitempty"`

	// MaxFileSize The maximum size of an export file in MB. Note that when this option is specified, multiple output files may be returned from the export.
	MaxFileSize   *int `json:"max_file_size,omitempty"`
	Notifications *struct {
		Email *bool `json:"email,omitempty"`
	} `json:"notifications,omitempty"`

	// SegmentIds IDs of the contact segments you want to export.
	SegmentIds *[]string `json:"segment_ids,omitempty"`
}

// ImportContactJSONBody defines parameters for ImportContact.
type ImportContactJSONBody struct {
	// FieldMappings Import file header to reserved/custom field mapping.
	FieldMappings []string  `json:"field_mappings"`
	FileType      FileType1 `json:"file_type"`

	// ListIds All contacts will be added to each of the specified lists.
	ListIds *[]string `json:"list_ids,omitempty"`
}

// SearchContactJSONBody defines parameters for SearchContact.
type SearchContactJSONBody struct {
	// Query An SGQL search string or other pattern.
	Query string `json:"query"`
}

// ListContactByEmailJSONBody defines parameters for ListContactByEmail.
type ListContactByEmailJSONBody struct {
	// AnonymousId The contact's Anonymous ID.
	AnonymousId *string `json:"anonymous_id,omitempty"`

	// Emails One or more primary and/or alternate email addresses to search for in your Marketing Campaigns contacts.
	Emails []string `json:"emails"`

	// ExternalId The contact's External ID.
	ExternalId *string `json:"external_id,omitempty"`

	// PhoneNumberId The contact's Phone Number ID. This is required to be a valid phone number.
	PhoneNumberId *string `json:"phone_number_id,omitempty"`
}

// GetContactByIdentifiersJSONBody defines parameters for GetContactByIdentifiers.
type GetContactByIdentifiersJSONBody struct {
	// Identifiers One or more more identifier values to search for in your Marketing Campaigns contacts.
	Identifiers []struct {
		// AnonymousId The contact's Anonymous ID.
		AnonymousId *string `json:"anonymous_id,omitempty"`
		Email       *string `json:"email,omitempty"`

		// ExternalId The contact's External ID.
		ExternalId *string `json:"external_id,omitempty"`

		// PhoneNumberId The contact's Phone Number ID. This is required to be a valid phone number.
		PhoneNumberId *string `json:"phone_number_id,omitempty"`
	} `json:"identifiers"`
}

// DeleteContactIdentifierJSONBody defines parameters for DeleteContactIdentifier.
type DeleteContactIdentifierJSONBody struct {
	IdentifierType IdentifierType `json:"identifier_type"`

	// IdentifierValue The value of the identifier you want to remove from the contact.
	IdentifierValue string `json:"identifier_value"`
}

// UpdateContactJSONRequestBody defines body for UpdateContact for application/json ContentType.
type UpdateContactJSONRequestBody UpdateContactJSONBody

// ListBatchedContactJSONRequestBody defines body for ListBatchedContact for application/json ContentType.
type ListBatchedContactJSONRequestBody ListBatchedContactJSONBody

// ExportContactJSONRequestBody defines body for ExportContact for application/json ContentType.
type ExportContactJSONRequestBody ExportContactJSONBody

// ImportContactJSONRequestBody defines body for ImportContact for application/json ContentType.
type ImportContactJSONRequestBody ImportContactJSONBody

// SearchContactJSONRequestBody defines body for SearchContact for application/json ContentType.
type SearchContactJSONRequestBody SearchContactJSONBody

// ListContactByEmailJSONRequestBody defines body for ListContactByEmail for application/json ContentType.
type ListContactByEmailJSONRequestBody ListContactByEmailJSONBody

// GetContactByIdentifiersJSONRequestBody defines body for GetContactByIdentifiers for application/json ContentType.
type GetContactByIdentifiersJSONRequestBody GetContactByIdentifiersJSONBody

// DeleteContactIdentifierJSONRequestBody defines body for DeleteContactIdentifier for application/json ContentType.
type DeleteContactIdentifierJSONRequestBody DeleteContactIdentifierJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteContact request
	DeleteContact(ctx context.Context, params *DeleteContactParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContact request
	ListContact(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateContactWithBody request with any body
	UpdateContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateContact(ctx context.Context, body UpdateContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchedContactWithBody request with any body
	ListBatchedContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListBatchedContact(ctx context.Context, body ListBatchedContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContactCount request
	ListContactCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExportContact request
	ListExportContact(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportContactWithBody request with any body
	ExportContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportContact(ctx context.Context, body ExportContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExportContact request
	GetExportContact(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportContactWithBody request with any body
	ImportContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportContact(ctx context.Context, body ImportContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImportContact request
	GetImportContact(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchContactWithBody request with any body
	SearchContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchContact(ctx context.Context, body SearchContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContactByEmailWithBody request with any body
	ListContactByEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListContactByEmail(ctx context.Context, body ListContactByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContactByIdentifiersWithBody request with any body
	GetContactByIdentifiersWithBody(ctx context.Context, identifierType IdentifierType1, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetContactByIdentifiers(ctx context.Context, identifierType IdentifierType1, body GetContactByIdentifiersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteContactIdentifierWithBody request with any body
	DeleteContactIdentifierWithBody(ctx context.Context, contactId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteContactIdentifier(ctx context.Context, contactId string, body DeleteContactIdentifierJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContact request
	GetContact(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteContact(ctx context.Context, params *DeleteContactParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteContactRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContact(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContactRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContactRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContact(ctx context.Context, body UpdateContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContactRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchedContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchedContactRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchedContact(ctx context.Context, body ListBatchedContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchedContactRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContactCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContactCountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExportContact(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExportContactRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportContactRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportContact(ctx context.Context, body ExportContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportContactRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExportContact(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExportContactRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportContactRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportContact(ctx context.Context, body ImportContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportContactRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImportContact(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImportContactRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchContactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchContactRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchContact(ctx context.Context, body SearchContactJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchContactRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContactByEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContactByEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContactByEmail(ctx context.Context, body ListContactByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContactByEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContactByIdentifiersWithBody(ctx context.Context, identifierType IdentifierType1, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContactByIdentifiersRequestWithBody(c.Server, identifierType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContactByIdentifiers(ctx context.Context, identifierType IdentifierType1, body GetContactByIdentifiersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContactByIdentifiersRequest(c.Server, identifierType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteContactIdentifierWithBody(ctx context.Context, contactId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteContactIdentifierRequestWithBody(c.Server, contactId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteContactIdentifier(ctx context.Context, contactId string, body DeleteContactIdentifierJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteContactIdentifierRequest(c.Server, contactId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContact(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContactRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteContactRequest generates requests for DeleteContact
func NewDeleteContactRequest(server string, params *DeleteContactParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteAllContacts != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_all_contacts", runtime.ParamLocationQuery, *params.DeleteAllContacts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Ids != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListContactRequest generates requests for ListContact
func NewListContactRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateContactRequest calls the generic UpdateContact builder with application/json body
func NewUpdateContactRequest(server string, body UpdateContactJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateContactRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateContactRequestWithBody generates requests for UpdateContact with any type of body
func NewUpdateContactRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBatchedContactRequest calls the generic ListBatchedContact builder with application/json body
func NewListBatchedContactRequest(server string, body ListBatchedContactJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListBatchedContactRequestWithBody(server, "application/json", bodyReader)
}

// NewListBatchedContactRequestWithBody generates requests for ListBatchedContact with any type of body
func NewListBatchedContactRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/batch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListContactCountRequest generates requests for ListContactCount
func NewListContactCountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListExportContactRequest generates requests for ListExportContact
func NewListExportContactRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportContactRequest calls the generic ExportContact builder with application/json body
func NewExportContactRequest(server string, body ExportContactJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportContactRequestWithBody(server, "application/json", bodyReader)
}

// NewExportContactRequestWithBody generates requests for ExportContact with any type of body
func NewExportContactRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExportContactRequest generates requests for GetExportContact
func NewGetExportContactRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/exports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportContactRequest calls the generic ImportContact builder with application/json body
func NewImportContactRequest(server string, body ImportContactJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportContactRequestWithBody(server, "application/json", bodyReader)
}

// NewImportContactRequestWithBody generates requests for ImportContact with any type of body
func NewImportContactRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/imports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetImportContactRequest generates requests for GetImportContact
func NewGetImportContactRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/imports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchContactRequest calls the generic SearchContact builder with application/json body
func NewSearchContactRequest(server string, body SearchContactJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchContactRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchContactRequestWithBody generates requests for SearchContact with any type of body
func NewSearchContactRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListContactByEmailRequest calls the generic ListContactByEmail builder with application/json body
func NewListContactByEmailRequest(server string, body ListContactByEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListContactByEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewListContactByEmailRequestWithBody generates requests for ListContactByEmail with any type of body
func NewListContactByEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/search/emails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetContactByIdentifiersRequest calls the generic GetContactByIdentifiers builder with application/json body
func NewGetContactByIdentifiersRequest(server string, identifierType IdentifierType1, body GetContactByIdentifiersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetContactByIdentifiersRequestWithBody(server, identifierType, "application/json", bodyReader)
}

// NewGetContactByIdentifiersRequestWithBody generates requests for GetContactByIdentifiers with any type of body
func NewGetContactByIdentifiersRequestWithBody(server string, identifierType IdentifierType1, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "identifier_type", runtime.ParamLocationPath, identifierType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/search/identifiers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteContactIdentifierRequest calls the generic DeleteContactIdentifier builder with application/json body
func NewDeleteContactIdentifierRequest(server string, contactId string, body DeleteContactIdentifierJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteContactIdentifierRequestWithBody(server, contactId, "application/json", bodyReader)
}

// NewDeleteContactIdentifierRequestWithBody generates requests for DeleteContactIdentifier with any type of body
func NewDeleteContactIdentifierRequestWithBody(server string, contactId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contact_id", runtime.ParamLocationPath, contactId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/%s/identifiers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetContactRequest generates requests for GetContact
func NewGetContactRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/marketing/contacts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteContactWithResponse request
	DeleteContactWithResponse(ctx context.Context, params *DeleteContactParams, reqEditors ...RequestEditorFn) (*DeleteContactResponse, error)

	// ListContactWithResponse request
	ListContactWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListContactResponse, error)

	// UpdateContactWithBodyWithResponse request with any body
	UpdateContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContactResponse, error)

	UpdateContactWithResponse(ctx context.Context, body UpdateContactJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContactResponse, error)

	// ListBatchedContactWithBodyWithResponse request with any body
	ListBatchedContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBatchedContactResponse, error)

	ListBatchedContactWithResponse(ctx context.Context, body ListBatchedContactJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBatchedContactResponse, error)

	// ListContactCountWithResponse request
	ListContactCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListContactCountResponse, error)

	// ListExportContactWithResponse request
	ListExportContactWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListExportContactResponse, error)

	// ExportContactWithBodyWithResponse request with any body
	ExportContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportContactResponse, error)

	ExportContactWithResponse(ctx context.Context, body ExportContactJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportContactResponse, error)

	// GetExportContactWithResponse request
	GetExportContactWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetExportContactResponse, error)

	// ImportContactWithBodyWithResponse request with any body
	ImportContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportContactResponse, error)

	ImportContactWithResponse(ctx context.Context, body ImportContactJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportContactResponse, error)

	// GetImportContactWithResponse request
	GetImportContactWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetImportContactResponse, error)

	// SearchContactWithBodyWithResponse request with any body
	SearchContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchContactResponse, error)

	SearchContactWithResponse(ctx context.Context, body SearchContactJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchContactResponse, error)

	// ListContactByEmailWithBodyWithResponse request with any body
	ListContactByEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListContactByEmailResponse, error)

	ListContactByEmailWithResponse(ctx context.Context, body ListContactByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*ListContactByEmailResponse, error)

	// GetContactByIdentifiersWithBodyWithResponse request with any body
	GetContactByIdentifiersWithBodyWithResponse(ctx context.Context, identifierType IdentifierType1, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetContactByIdentifiersResponse, error)

	GetContactByIdentifiersWithResponse(ctx context.Context, identifierType IdentifierType1, body GetContactByIdentifiersJSONRequestBody, reqEditors ...RequestEditorFn) (*GetContactByIdentifiersResponse, error)

	// DeleteContactIdentifierWithBodyWithResponse request with any body
	DeleteContactIdentifierWithBodyWithResponse(ctx context.Context, contactId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteContactIdentifierResponse, error)

	DeleteContactIdentifierWithResponse(ctx context.Context, contactId string, body DeleteContactIdentifierJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteContactIdentifierResponse, error)

	// GetContactWithResponse request
	GetContactWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetContactResponse, error)
}

type DeleteContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// JobId The deletion job ID.
		JobId map[string]interface{} `json:"job_id"`
	}
	JSON400 *struct {
		Errors []map[string]interface{} `json:"errors"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *MarketingContacts404
	JSON500 *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r DeleteContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Metadata     *SelfMetadata      `json:"_metadata,omitempty"`
		ContactCount *int               `json:"contact_count,omitempty"`
		Result       *[]ContactDetails3 `json:"result,omitempty"`
	}
	JSON400 *struct {
		Errors *[]ContactsError `json:"errors,omitempty"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *map[string]interface{}
	JSON500 *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r ListContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// JobId Indicates that the contacts are queued for processing. Check the job status with the "Import Contacts Status" endpoint.
		JobId *string `json:"job_id,omitempty"`
	}
	JSON400 *struct {
		Errors *[]ContactsError `json:"errors,omitempty"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *MarketingContacts404
	JSON500 *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r UpdateContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchedContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *[]ContactDetails3 `json:"result,omitempty"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *map[string]interface{}
	JSON500 *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r ListBatchedContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchedContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContactCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BillableBreakdown `billable_breakdown` will only appear to the parent user in an account with subusers.
		BillableBreakdown *struct {
			// Breakdown A map of each subuser's billable contact usage. Each key is the subuser's ID and each value is the usage thus far this month.
			Breakdown *map[string]interface{} `json:"breakdown,omitempty"`

			// Total The sum of all the subuser's billable contacts
			Total *int `json:"total,omitempty"`
		} `json:"billable_breakdown,omitempty"`

		// BillableCount The count of contacts this month for billing purposes.
		BillableCount *int `json:"billable_count,omitempty"`

		// ContactCount The total number of contacts.
		ContactCount int `json:"contact_count"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *MarketingContacts404
	JSON500 *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r ListContactCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContactCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExportContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Metadata *struct {
			// Next Link to next page.
			Next *string `json:"next,omitempty"`
			Prev *string `json:"prev,omitempty"`

			// Self Link to this page.
			Self *string `json:"self,omitempty"`
		} `json:"_metadata,omitempty"`
		Result *[]struct {
			Metadata *struct {
				Next *string `json:"next,omitempty"`
				Prev *string `json:"prev,omitempty"`
				Self *string `json:"self,omitempty"`
			} `json:"_metadata,omitempty"`

			// CompletedAt This ISO8601 timestamp when the export was completed.
			CompletedAt *string `json:"completed_at,omitempty"`

			// CreatedAt This ISO8601 timestamp when the export was created.
			CreatedAt *string `json:"created_at,omitempty"`

			// ExpiresAt This ISO8601 timestamp when the export expires.
			ExpiresAt *string `json:"expires_at,omitempty"`

			// ExportType Allowed types: `contacts_export`, `list_export`, or `segment_export`.
			ExportType *string `json:"export_type,omitempty"`

			// Id Export jobs ID.
			Id    *string `json:"id,omitempty"`
			Lists *[]struct {
				ID   *string `json:"ID,omitempty"`
				Name *string `json:"Name,omitempty"`
			} `json:"lists,omitempty"`
			Segments *[]struct {
				ID   *string `json:"ID,omitempty"`
				Name *string `json:"Name,omitempty"`
			} `json:"segments,omitempty"`

			// Status Allowed values: `pending`, `ready`, or `failure`.
			Status *string `json:"status,omitempty"`

			// Urls One or more download URLs for the contact file(s) if the status is `ready`.
			Urls *[]string `json:"urls,omitempty"`

			// UserId User ID.
			UserId *string `json:"user_id,omitempty"`
		} `json:"result,omitempty"`
	}
	JSON400 *struct {
		Errors *[]struct {
			ErrorId *string `json:"error_id,omitempty"`
			Message string  `json:"message"`
		} `json:"errors,omitempty"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *MarketingContacts404
	JSON500 *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r ListExportContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExportContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		Metadata Metadata `json:"_metadata"`

		// Id The ID of the export job.
		Id *string `json:"id,omitempty"`
	}
	JSON400 *struct {
		Errors *[]ContactsError `json:"errors,omitempty"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *MarketingContacts404
	JSON500 *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r ExportContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExportContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContactExport
	JSON400      *struct {
		Errors *[]ContactsError `json:"errors,omitempty"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *MarketingContacts404
	JSON500 *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r GetExportContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExportContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// JobId The ID of the import job.
		JobId *string `json:"job_id,omitempty"`

		// UploadHeaders A list of headers that must be included in PUT request.
		UploadHeaders *[]struct {
			Header string `json:"header"`
			Value  string `json:"value"`
		} `json:"upload_headers,omitempty"`

		// UploadUri The URI to PUT the upload file to.
		UploadUri *string `json:"upload_uri,omitempty"`
	}
	JSON400 *struct {
		Errors []ContactsError `json:"errors"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *struct {
		Errors []ContactsError `json:"errors"`
	}
	JSON500 *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r ImportContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImportContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContactImport
	JSON400      *struct {
		Errors *ContactsError `json:"errors,omitempty"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *MarketingContacts404
	JSON500 *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r GetImportContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImportContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Metadata *SelfMetadata `json:"_metadata,omitempty"`

		// ContactCount The total number of contacts matched.
		ContactCount float32            `json:"contact_count"`
		Result       *[]ContactDetails3 `json:"result,omitempty"`
	}
	JSON400 *struct {
		Errors *[]struct {
			Field   *string `json:"field,omitempty"`
			Message *string `json:"message,omitempty"`
		} `json:"errors,omitempty"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *MarketingContacts404
	JSON500 *struct {
		Errors *[]struct {
			Message *string `json:"message,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContactByEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *map[string]interface{} `json:"result,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *ErrorResponse
	JSON500 *struct {
		Errors *[]struct {
			Message *string `json:"message,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListContactByEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContactByEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContactByIdentifiersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *map[string]struct {
			Contact *ContactDetails3 `json:"contact,omitempty"`
			Error   *string          `json:"error,omitempty"`
		} `json:"result,omitempty"`
	}
	JSON400 *ContactsError
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *ContactsError
	JSON500 *struct {
		Errors *[]struct {
			Message *string `json:"message,omitempty"`
		} `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetContactByIdentifiersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContactByIdentifiersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteContactIdentifierResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// JobId The deletion job ID.
		JobId map[string]interface{} `json:"job_id"`
	}
	JSON400 *struct {
		Errors []map[string]interface{} `json:"errors"`
	}
	JSON401 *MarketingContacts401
	JSON403 *MarketingContacts403
	JSON404 *MarketingContacts404
	JSON500 *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r DeleteContactIdentifierResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteContactIdentifierResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContactDetails3
	JSON401      *MarketingContacts401
	JSON403      *MarketingContacts403
	JSON500      *MarketingContacts500
}

// Status returns HTTPResponse.Status
func (r GetContactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteContactWithResponse request returning *DeleteContactResponse
func (c *ClientWithResponses) DeleteContactWithResponse(ctx context.Context, params *DeleteContactParams, reqEditors ...RequestEditorFn) (*DeleteContactResponse, error) {
	rsp, err := c.DeleteContact(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContactResponse(rsp)
}

// ListContactWithResponse request returning *ListContactResponse
func (c *ClientWithResponses) ListContactWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListContactResponse, error) {
	rsp, err := c.ListContact(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContactResponse(rsp)
}

// UpdateContactWithBodyWithResponse request with arbitrary body returning *UpdateContactResponse
func (c *ClientWithResponses) UpdateContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContactResponse, error) {
	rsp, err := c.UpdateContactWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContactResponse(rsp)
}

func (c *ClientWithResponses) UpdateContactWithResponse(ctx context.Context, body UpdateContactJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContactResponse, error) {
	rsp, err := c.UpdateContact(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContactResponse(rsp)
}

// ListBatchedContactWithBodyWithResponse request with arbitrary body returning *ListBatchedContactResponse
func (c *ClientWithResponses) ListBatchedContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBatchedContactResponse, error) {
	rsp, err := c.ListBatchedContactWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchedContactResponse(rsp)
}

func (c *ClientWithResponses) ListBatchedContactWithResponse(ctx context.Context, body ListBatchedContactJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBatchedContactResponse, error) {
	rsp, err := c.ListBatchedContact(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchedContactResponse(rsp)
}

// ListContactCountWithResponse request returning *ListContactCountResponse
func (c *ClientWithResponses) ListContactCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListContactCountResponse, error) {
	rsp, err := c.ListContactCount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContactCountResponse(rsp)
}

// ListExportContactWithResponse request returning *ListExportContactResponse
func (c *ClientWithResponses) ListExportContactWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListExportContactResponse, error) {
	rsp, err := c.ListExportContact(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExportContactResponse(rsp)
}

// ExportContactWithBodyWithResponse request with arbitrary body returning *ExportContactResponse
func (c *ClientWithResponses) ExportContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportContactResponse, error) {
	rsp, err := c.ExportContactWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportContactResponse(rsp)
}

func (c *ClientWithResponses) ExportContactWithResponse(ctx context.Context, body ExportContactJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportContactResponse, error) {
	rsp, err := c.ExportContact(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportContactResponse(rsp)
}

// GetExportContactWithResponse request returning *GetExportContactResponse
func (c *ClientWithResponses) GetExportContactWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetExportContactResponse, error) {
	rsp, err := c.GetExportContact(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExportContactResponse(rsp)
}

// ImportContactWithBodyWithResponse request with arbitrary body returning *ImportContactResponse
func (c *ClientWithResponses) ImportContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportContactResponse, error) {
	rsp, err := c.ImportContactWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportContactResponse(rsp)
}

func (c *ClientWithResponses) ImportContactWithResponse(ctx context.Context, body ImportContactJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportContactResponse, error) {
	rsp, err := c.ImportContact(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportContactResponse(rsp)
}

// GetImportContactWithResponse request returning *GetImportContactResponse
func (c *ClientWithResponses) GetImportContactWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetImportContactResponse, error) {
	rsp, err := c.GetImportContact(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImportContactResponse(rsp)
}

// SearchContactWithBodyWithResponse request with arbitrary body returning *SearchContactResponse
func (c *ClientWithResponses) SearchContactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchContactResponse, error) {
	rsp, err := c.SearchContactWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchContactResponse(rsp)
}

func (c *ClientWithResponses) SearchContactWithResponse(ctx context.Context, body SearchContactJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchContactResponse, error) {
	rsp, err := c.SearchContact(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchContactResponse(rsp)
}

// ListContactByEmailWithBodyWithResponse request with arbitrary body returning *ListContactByEmailResponse
func (c *ClientWithResponses) ListContactByEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListContactByEmailResponse, error) {
	rsp, err := c.ListContactByEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContactByEmailResponse(rsp)
}

func (c *ClientWithResponses) ListContactByEmailWithResponse(ctx context.Context, body ListContactByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*ListContactByEmailResponse, error) {
	rsp, err := c.ListContactByEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContactByEmailResponse(rsp)
}

// GetContactByIdentifiersWithBodyWithResponse request with arbitrary body returning *GetContactByIdentifiersResponse
func (c *ClientWithResponses) GetContactByIdentifiersWithBodyWithResponse(ctx context.Context, identifierType IdentifierType1, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetContactByIdentifiersResponse, error) {
	rsp, err := c.GetContactByIdentifiersWithBody(ctx, identifierType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContactByIdentifiersResponse(rsp)
}

func (c *ClientWithResponses) GetContactByIdentifiersWithResponse(ctx context.Context, identifierType IdentifierType1, body GetContactByIdentifiersJSONRequestBody, reqEditors ...RequestEditorFn) (*GetContactByIdentifiersResponse, error) {
	rsp, err := c.GetContactByIdentifiers(ctx, identifierType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContactByIdentifiersResponse(rsp)
}

// DeleteContactIdentifierWithBodyWithResponse request with arbitrary body returning *DeleteContactIdentifierResponse
func (c *ClientWithResponses) DeleteContactIdentifierWithBodyWithResponse(ctx context.Context, contactId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteContactIdentifierResponse, error) {
	rsp, err := c.DeleteContactIdentifierWithBody(ctx, contactId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContactIdentifierResponse(rsp)
}

func (c *ClientWithResponses) DeleteContactIdentifierWithResponse(ctx context.Context, contactId string, body DeleteContactIdentifierJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteContactIdentifierResponse, error) {
	rsp, err := c.DeleteContactIdentifier(ctx, contactId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContactIdentifierResponse(rsp)
}

// GetContactWithResponse request returning *GetContactResponse
func (c *ClientWithResponses) GetContactWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetContactResponse, error) {
	rsp, err := c.GetContact(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContactResponse(rsp)
}

// ParseDeleteContactResponse parses an HTTP response from a DeleteContactWithResponse call
func ParseDeleteContactResponse(rsp *http.Response) (*DeleteContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// JobId The deletion job ID.
			JobId map[string]interface{} `json:"job_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []map[string]interface{} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MarketingContacts404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListContactResponse parses an HTTP response from a ListContactWithResponse call
func ParseListContactResponse(rsp *http.Response) (*ListContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Metadata     *SelfMetadata      `json:"_metadata,omitempty"`
			ContactCount *int               `json:"contact_count,omitempty"`
			Result       *[]ContactDetails3 `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]ContactsError `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateContactResponse parses an HTTP response from a UpdateContactWithResponse call
func ParseUpdateContactResponse(rsp *http.Response) (*UpdateContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// JobId Indicates that the contacts are queued for processing. Check the job status with the "Import Contacts Status" endpoint.
			JobId *string `json:"job_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]ContactsError `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MarketingContacts404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBatchedContactResponse parses an HTTP response from a ListBatchedContactWithResponse call
func ParseListBatchedContactResponse(rsp *http.Response) (*ListBatchedContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchedContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *[]ContactDetails3 `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListContactCountResponse parses an HTTP response from a ListContactCountWithResponse call
func ParseListContactCountResponse(rsp *http.Response) (*ListContactCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContactCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BillableBreakdown `billable_breakdown` will only appear to the parent user in an account with subusers.
			BillableBreakdown *struct {
				// Breakdown A map of each subuser's billable contact usage. Each key is the subuser's ID and each value is the usage thus far this month.
				Breakdown *map[string]interface{} `json:"breakdown,omitempty"`

				// Total The sum of all the subuser's billable contacts
				Total *int `json:"total,omitempty"`
			} `json:"billable_breakdown,omitempty"`

			// BillableCount The count of contacts this month for billing purposes.
			BillableCount *int `json:"billable_count,omitempty"`

			// ContactCount The total number of contacts.
			ContactCount int `json:"contact_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MarketingContacts404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListExportContactResponse parses an HTTP response from a ListExportContactWithResponse call
func ParseListExportContactResponse(rsp *http.Response) (*ListExportContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExportContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Metadata *struct {
				// Next Link to next page.
				Next *string `json:"next,omitempty"`
				Prev *string `json:"prev,omitempty"`

				// Self Link to this page.
				Self *string `json:"self,omitempty"`
			} `json:"_metadata,omitempty"`
			Result *[]struct {
				Metadata *struct {
					Next *string `json:"next,omitempty"`
					Prev *string `json:"prev,omitempty"`
					Self *string `json:"self,omitempty"`
				} `json:"_metadata,omitempty"`

				// CompletedAt This ISO8601 timestamp when the export was completed.
				CompletedAt *string `json:"completed_at,omitempty"`

				// CreatedAt This ISO8601 timestamp when the export was created.
				CreatedAt *string `json:"created_at,omitempty"`

				// ExpiresAt This ISO8601 timestamp when the export expires.
				ExpiresAt *string `json:"expires_at,omitempty"`

				// ExportType Allowed types: `contacts_export`, `list_export`, or `segment_export`.
				ExportType *string `json:"export_type,omitempty"`

				// Id Export jobs ID.
				Id    *string `json:"id,omitempty"`
				Lists *[]struct {
					ID   *string `json:"ID,omitempty"`
					Name *string `json:"Name,omitempty"`
				} `json:"lists,omitempty"`
				Segments *[]struct {
					ID   *string `json:"ID,omitempty"`
					Name *string `json:"Name,omitempty"`
				} `json:"segments,omitempty"`

				// Status Allowed values: `pending`, `ready`, or `failure`.
				Status *string `json:"status,omitempty"`

				// Urls One or more download URLs for the contact file(s) if the status is `ready`.
				Urls *[]string `json:"urls,omitempty"`

				// UserId User ID.
				UserId *string `json:"user_id,omitempty"`
			} `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]struct {
				ErrorId *string `json:"error_id,omitempty"`
				Message string  `json:"message"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MarketingContacts404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportContactResponse parses an HTTP response from a ExportContactWithResponse call
func ParseExportContactResponse(rsp *http.Response) (*ExportContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Metadata Metadata `json:"_metadata"`

			// Id The ID of the export job.
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]ContactsError `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MarketingContacts404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetExportContactResponse parses an HTTP response from a GetExportContactWithResponse call
func ParseGetExportContactResponse(rsp *http.Response) (*GetExportContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExportContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContactExport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]ContactsError `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MarketingContacts404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseImportContactResponse parses an HTTP response from a ImportContactWithResponse call
func ParseImportContactResponse(rsp *http.Response) (*ImportContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// JobId The ID of the import job.
			JobId *string `json:"job_id,omitempty"`

			// UploadHeaders A list of headers that must be included in PUT request.
			UploadHeaders *[]struct {
				Header string `json:"header"`
				Value  string `json:"value"`
			} `json:"upload_headers,omitempty"`

			// UploadUri The URI to PUT the upload file to.
			UploadUri *string `json:"upload_uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []ContactsError `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors []ContactsError `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetImportContactResponse parses an HTTP response from a GetImportContactWithResponse call
func ParseGetImportContactResponse(rsp *http.Response) (*GetImportContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImportContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContactImport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *ContactsError `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MarketingContacts404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchContactResponse parses an HTTP response from a SearchContactWithResponse call
func ParseSearchContactResponse(rsp *http.Response) (*SearchContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Metadata *SelfMetadata `json:"_metadata,omitempty"`

			// ContactCount The total number of contacts matched.
			ContactCount float32            `json:"contact_count"`
			Result       *[]ContactDetails3 `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors *[]struct {
				Field   *string `json:"field,omitempty"`
				Message *string `json:"message,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MarketingContacts404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *[]struct {
				Message *string `json:"message,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListContactByEmailResponse parses an HTTP response from a ListContactByEmailWithResponse call
func ParseListContactByEmailResponse(rsp *http.Response) (*ListContactByEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContactByEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *map[string]interface{} `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *[]struct {
				Message *string `json:"message,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetContactByIdentifiersResponse parses an HTTP response from a GetContactByIdentifiersWithResponse call
func ParseGetContactByIdentifiersResponse(rsp *http.Response) (*GetContactByIdentifiersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContactByIdentifiersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *map[string]struct {
				Contact *ContactDetails3 `json:"contact,omitempty"`
				Error   *string          `json:"error,omitempty"`
			} `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ContactsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ContactsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors *[]struct {
				Message *string `json:"message,omitempty"`
			} `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteContactIdentifierResponse parses an HTTP response from a DeleteContactIdentifierWithResponse call
func ParseDeleteContactIdentifierResponse(rsp *http.Response) (*DeleteContactIdentifierResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteContactIdentifierResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// JobId The deletion job ID.
			JobId map[string]interface{} `json:"job_id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []map[string]interface{} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MarketingContacts404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetContactResponse parses an HTTP response from a GetContactWithResponse call
func ParseGetContactResponse(rsp *http.Response) (*GetContactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContactDetails3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest MarketingContacts401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest MarketingContacts403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest MarketingContacts500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{
	"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",
	"//8hjo9Nea8AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
