{{ $s := parentService . }}{{ $goPath := goPath .File }}{{ $e := parentEntity . }}{{ $entityName := entityName $e }}{{ $system := domainSystemName2 .File }}
func (s *{{ $s.Name }}Handler) Get{{ .Name }}Configuration() *natsnodev1.ListenerConfiguration {

	return &natsnodev1.ListenerConfiguration{
		Entity:     &{{ $entityName.UpperCamelCase }}SpecEntity{},
		Procedure:  "{{ .Name }}",
		CQRS: optionv2pb.CQRSType_{{ getCQRSTypeEnumName .}},
        Topic:   CommandData{{ $entityName.UpperCamelCase }}Topic,
		StreamType: natsnodev1.NewInboundStream(),
		JetstreamConfiguration: &jetstream.ConsumerConfig{
			Durable:       "{{ $system.LowerCamelCase }}-{{ $entityName.LowerCamelCase }}-{{ .Name.LowerCamelCase }}",
			AckPolicy:     jetstream.AckExplicitPolicy,
			MemoryStorage: false,
		},
	}
}
{{ $methodDashCaseName := dashCase .Name }}

func (s *{{ $s.Name }}Handler) {{ .Name }}(ctx context.Context, req *connect.Request[{{ .Input.Name }}]) (*connect.Response[{{ .Output.Name }}], error) {

	tracer := *opentelemetryv1.Bound.Tracer

	parentSpanCtx := trace.SpanContextFromContext(ctx)
	ctx = trace.ContextWithRemoteSpanContext(ctx, parentSpanCtx)

	spec, ok := ctx.Value(sdkv2betalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}

	// Executes top level validation, no business domain validation
	_, validationSpan := tracer.Start(ctx, "{{ $methodDashCaseName }}-request-wire-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		fv, serr := sdkv2betalib.ConvertValidationErrorToFieldValidations(err)
		if serr != nil {
			return nil, serr
		}
		return nil, sdkv2betalib.ErrServerPreconditionFailed.WithBadRequest(&errdetails.BadRequest{FieldViolations: fv})
	}
	validationSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
	  spec.SpecData.FieldMask.Normalize()
	  if !spec.SpecData.FieldMask.IsValid(&{{ .Output.Name }}{}) {
	  return nil, sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
	  }
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(ctx, "{{ $methodDashCaseName }}-event-multiplex", trace.WithSpanKind(trace.SpanKindInternal))

	config := s.Get{{ .Name }}Configuration()
	reply, serr := natsnodev1.Bound.MultiplexCommandSync(handlerCtx, spec, &natsnodev1.SpecCommand{
		Request:        req.Msg,
		Stream:         config.StreamType,
		Procedure:      config.Procedure,
		CommandName:    "",
		CommandTopic:   config.Topic,
		EntityTypeName: config.Entity.TypeName(),
	})
	if serr != nil {
		return nil, serr
	}

	var s2 specv2pb.Spec
	err := proto.Unmarshal(reply.Data, &s2)
	if err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	if s2.SpecError != nil {
		return nil, sdkv2betalib.NewSpecErrorFromStatus(s2.SpecError)
	}

	if s2.SpecData == nil || s2.SpecData.Data == nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("The response did not contain any spec data response. Investigate. Bug."))
	}

	var response {{ .Output.Name }}
	if err = anypb.UnmarshalTo(s2.SpecData.Data, &response, proto.UnmarshalOptions{}); err != nil {
		return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	handlerSpan.End()

	return connect.NewResponse(&response), nil

}
