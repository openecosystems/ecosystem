{{ $s := parentService . }}{{ $goPath := goPath .File }}{{ $e := parentEntity . }}{{ $entityName := entityName $e }}{{ $system := domainSystemName2 .File }}
func (s *{{ $s.Name }}Handler) Get{{ .Name }}Configuration() *natsnodev1.ListenerConfiguration {

	return &natsnodev1.ListenerConfiguration{
		Entity:     &{{ $entityName.UpperCamelCase }}SpecEntity{},
		Procedure:  "{{ .Name }}",
		CQRS: optionv2pb.CQRSType_{{ getCQRSTypeEnumName .}},
        Topic:   EventData{{ $entityName.UpperCamelCase }}Topic,
		StreamType: natsnodev1.NewInboundStream(),
		JetstreamConfiguration: &jetstream.ConsumerConfig{
			Durable:       "{{ $system.LowerCamelCase }}-{{ $entityName.LowerCamelCase }}-{{ .Name.LowerCamelCase }}",
			AckPolicy:     jetstream.AckExplicitPolicy,
			MemoryStorage: false,
		},
	}
}
{{ $methodDashCaseName := dashCase .Name }}

func (s *{{ $s.Name }}Handler) {{ .Name }}(ctx context.Context, req *connect.Request[{{ .Input.Name }}], stream *connect.ServerStream[{{ .Output.Name }}]) error {

    tracer := *opentelemetryv1.Bound.Tracer
    n := natsnodev1.Bound.Nats

    parentSpanCtx := trace.SpanContextFromContext(ctx)
    ctx = trace.ContextWithRemoteSpanContext(ctx, parentSpanCtx)

	spec, ok := ctx.Value(sdkv2betalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}

    // Executes top level validation, no business domain validation
    _, validationSpan := tracer.Start(ctx, "{{ $methodDashCaseName }}-request-wire-validation", trace.WithSpanKind(trace.SpanKindInternal))
    v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		fv, serr := sdkv2betalib.ConvertValidationErrorToFieldValidations(err)
		if serr != nil {
			return serr
		}
		return sdkv2betalib.ErrServerPreconditionFailed.WithBadRequest(&errdetails.BadRequest{FieldViolations: fv})
	}
    validationSpan.End()

    // Validate field mask
    if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
      spec.SpecData.FieldMask.Normalize()
      if !spec.SpecData.FieldMask.IsValid(&{{ .Output.Name }}{}) {
      return sdkv2betalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
      }
    }

    // Distributed Domain Handler
    handlerCtx, handlerSpan := tracer.Start(ctx, "{{ $methodDashCaseName }}-event-multiplex", trace.WithSpanKind(trace.SpanKindInternal))
    defer handlerSpan.End()

    config := s.Get{{ .Name }}Configuration()
    return natsnodev1.MultiplexEventStreamSync[{{ .Output.Name }}](handlerCtx, spec, &natsnodev1.SpecStreamEvent{
		Request:        req.Msg,
		Stream:         config.StreamType,
		Procedure:      config.Procedure,
		EventName:      "",
		EventTopic:     config.Topic,
		EntityTypeName: config.Entity.TypeName(),
	}, n, stream, func(m *nats.Msg) (*{{ .Output.Name }}, error) {

        var s2 specv2pb.Spec
        err := proto.Unmarshal(m.Data, &s2)
        if err != nil {
            return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
        }

        if s2.SpecError != nil {
            return nil, sdkv2betalib.NewSpecErrorFromStatus(s2.SpecError)
        }

        if s2.SpecData == nil || s2.SpecData.Data == nil {
            return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(errors.New("The response did not contain any spec data response. Investigate. Bug."))
        }

        var response {{ .Output.Name }}
        if err = anypb.UnmarshalTo(s2.SpecData.Data, &response, proto.UnmarshalOptions{}); err != nil {
            return nil, sdkv2betalib.ErrServerInternal.WithInternalErrorDetail(err)
        }

		return &response, nil
	})
}