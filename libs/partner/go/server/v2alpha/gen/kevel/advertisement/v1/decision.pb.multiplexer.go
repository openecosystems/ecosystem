// Code generated by protoc-gen-platform go/multiplexer. DO NOT EDIT.
// source: kevel/advertisement/v1/decision.proto

package advertisementv1pbsrv

import (
	"connectrpc.com/connect"
	"errors"
	"github.com/openecosystems/ecosystem/libs/partner/go/model/gen/kevel/advertisement/v1"
	"github.com/openecosystems/ecosystem/libs/partner/go/nats/v1"
	"github.com/openecosystems/ecosystem/libs/partner/go/opentelemetry/v1"
	"github.com/openecosystems/ecosystem/libs/partner/go/protobuf/gen/kevel/advertisement/v1"
	"github.com/openecosystems/ecosystem/libs/partner/go/protovalidate/v0"
	"github.com/openecosystems/ecosystem/libs/partner/go/zap/v1"
	"github.com/openecosystems/ecosystem/libs/public/go/sdk/v2alpha"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/protobuf/proto"

	"github.com/openecosystems/ecosystem/libs/protobuf/go/protobuf/gen/platform/spec/v2"

	_ "github.com/openecosystems/ecosystem/libs/protobuf/go/protobuf/gen/platform/spec/v2"

	"context"
)

// DecisionServiceHandler is the domain level implementation of the server API for mutations of the DecisionService service
type DecisionServiceHandler struct{}

func (s *DecisionServiceHandler) GetDecisions(ctx context.Context, req *connect.Request[advertisementv1pb.GetDecisionsRequest]) (*connect.Response[advertisementv1pb.GetDecisionsResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer
	log := *zaploggerv1.Bound.Logger

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Spec Propagation
	specCtx, specSpan := tracer.Start(validationCtx, "spec-propagation", trace.WithSpanKind(trace.SpanKindInternal))
	spec, ok := ctx.Value(sdkv2alphalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}
	specSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&advertisementv1pb.GetDecisionsResponse{}) {
			log.Error("Invalid field mask")
			return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(specCtx, "event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	entity := advertisementv1pbmodel.DecisionSpecEntity{}
	reply, err2 := natsnodev1.Bound.MultiplexCommandSync(handlerCtx, spec, &natsnodev1.SpecCommand{
		Request:        req.Msg,
		Stream:         natsnodev1.NewInboundStream(),
		CommandName:    "",
		CommandTopic:   advertisementv1pbmodel.CommandDataDecisionTopic,
		EntityTypeName: entity.TypeName(),
	})
	if err2 != nil {
		log.Error(err2.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	var dd advertisementv1pb.GetDecisionsResponse
	err3 := proto.Unmarshal(reply.Data, &dd)
	if err3 != nil {
		log.Error(err3.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	handlerSpan.End()

	return connect.NewResponse(&dd), nil

}

func (s *DecisionServiceHandler) AddCustomProperties(ctx context.Context, req *connect.Request[advertisementv1pb.AddCustomPropertiesRequest]) (*connect.Response[advertisementv1pb.AddCustomPropertiesResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer
	log := *zaploggerv1.Bound.Logger

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Spec Propagation
	specCtx, specSpan := tracer.Start(validationCtx, "spec-propagation", trace.WithSpanKind(trace.SpanKindInternal))
	spec, ok := ctx.Value(sdkv2alphalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}
	specSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&advertisementv1pb.AddCustomPropertiesResponse{}) {
			log.Error("Invalid field mask")
			return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(specCtx, "event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	entity := advertisementv1pbmodel.DecisionSpecEntity{}
	reply, err2 := natsnodev1.Bound.MultiplexCommandSync(handlerCtx, spec, &natsnodev1.SpecCommand{
		Request:        req.Msg,
		Stream:         natsnodev1.NewInboundStream(),
		CommandName:    "",
		CommandTopic:   advertisementv1pbmodel.CommandDataDecisionTopic,
		EntityTypeName: entity.TypeName(),
	})
	if err2 != nil {
		log.Error(err2.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	var dd advertisementv1pb.AddCustomPropertiesResponse
	err3 := proto.Unmarshal(reply.Data, &dd)
	if err3 != nil {
		log.Error(err3.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	handlerSpan.End()

	return connect.NewResponse(&dd), nil

}

func (s *DecisionServiceHandler) Forget(ctx context.Context, req *connect.Request[advertisementv1pb.ForgetRequest]) (*connect.Response[advertisementv1pb.ForgetResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer
	log := *zaploggerv1.Bound.Logger

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Spec Propagation
	specCtx, specSpan := tracer.Start(validationCtx, "spec-propagation", trace.WithSpanKind(trace.SpanKindInternal))
	spec, ok := ctx.Value(sdkv2alphalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}
	specSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&advertisementv1pb.ForgetResponse{}) {
			log.Error("Invalid field mask")
			return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(specCtx, "event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	entity := advertisementv1pbmodel.DecisionSpecEntity{}
	reply, err2 := natsnodev1.Bound.MultiplexCommandSync(handlerCtx, spec, &natsnodev1.SpecCommand{
		Request:        req.Msg,
		Stream:         natsnodev1.NewInboundStream(),
		CommandName:    "",
		CommandTopic:   advertisementv1pbmodel.CommandDataDecisionTopic,
		EntityTypeName: entity.TypeName(),
	})
	if err2 != nil {
		log.Error(err2.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	var dd advertisementv1pb.ForgetResponse
	err3 := proto.Unmarshal(reply.Data, &dd)
	if err3 != nil {
		log.Error(err3.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	handlerSpan.End()

	return connect.NewResponse(&dd), nil

}

func (s *DecisionServiceHandler) GdprConsent(ctx context.Context, req *connect.Request[advertisementv1pb.GdprConsentRequest]) (*connect.Response[advertisementv1pb.GdprConsentResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer
	log := *zaploggerv1.Bound.Logger

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Spec Propagation
	specCtx, specSpan := tracer.Start(validationCtx, "spec-propagation", trace.WithSpanKind(trace.SpanKindInternal))
	spec, ok := ctx.Value(sdkv2alphalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}
	specSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&advertisementv1pb.GdprConsentResponse{}) {
			log.Error("Invalid field mask")
			return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(specCtx, "event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	entity := advertisementv1pbmodel.DecisionSpecEntity{}
	reply, err2 := natsnodev1.Bound.MultiplexCommandSync(handlerCtx, spec, &natsnodev1.SpecCommand{
		Request:        req.Msg,
		Stream:         natsnodev1.NewInboundStream(),
		CommandName:    "",
		CommandTopic:   advertisementv1pbmodel.CommandDataDecisionTopic,
		EntityTypeName: entity.TypeName(),
	})
	if err2 != nil {
		log.Error(err2.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	var dd advertisementv1pb.GdprConsentResponse
	err3 := proto.Unmarshal(reply.Data, &dd)
	if err3 != nil {
		log.Error(err3.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	handlerSpan.End()

	return connect.NewResponse(&dd), nil

}

func (s *DecisionServiceHandler) AddInterests(ctx context.Context, req *connect.Request[advertisementv1pb.AddInterestsRequest]) (*connect.Response[advertisementv1pb.AddInterestsResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer
	log := *zaploggerv1.Bound.Logger

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Spec Propagation
	specCtx, specSpan := tracer.Start(validationCtx, "spec-propagation", trace.WithSpanKind(trace.SpanKindInternal))
	spec, ok := ctx.Value(sdkv2alphalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}
	specSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&advertisementv1pb.AddInterestsResponse{}) {
			log.Error("Invalid field mask")
			return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(specCtx, "event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	entity := advertisementv1pbmodel.DecisionSpecEntity{}
	reply, err2 := natsnodev1.Bound.MultiplexEventSync(handlerCtx, spec, &natsnodev1.SpecEvent{
		Request:        req.Msg,
		Stream:         natsnodev1.NewInboundStream(),
		EventName:      "",
		EventTopic:     advertisementv1pbmodel.EventDataDecisionTopic,
		EntityTypeName: entity.TypeName(),
	})
	if err2 != nil {
		log.Error(err2.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	var dd advertisementv1pb.AddInterestsResponse
	err3 := proto.Unmarshal(reply.Data, &dd)
	if err3 != nil {
		log.Error(err3.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	handlerSpan.End()

	return connect.NewResponse(&dd), nil

}

func (s *DecisionServiceHandler) AddRetargetingSegment(ctx context.Context, req *connect.Request[advertisementv1pb.AddRetargetingSegmentRequest]) (*connect.Response[advertisementv1pb.AddRetargetingSegmentResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer
	log := *zaploggerv1.Bound.Logger

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Spec Propagation
	specCtx, specSpan := tracer.Start(validationCtx, "spec-propagation", trace.WithSpanKind(trace.SpanKindInternal))
	spec, ok := ctx.Value(sdkv2alphalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}
	specSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&advertisementv1pb.AddRetargetingSegmentResponse{}) {
			log.Error("Invalid field mask")
			return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(specCtx, "event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	entity := advertisementv1pbmodel.DecisionSpecEntity{}
	reply, err2 := natsnodev1.Bound.MultiplexEventSync(handlerCtx, spec, &natsnodev1.SpecEvent{
		Request:        req.Msg,
		Stream:         natsnodev1.NewInboundStream(),
		EventName:      "",
		EventTopic:     advertisementv1pbmodel.EventDataDecisionTopic,
		EntityTypeName: entity.TypeName(),
	})
	if err2 != nil {
		log.Error(err2.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	var dd advertisementv1pb.AddRetargetingSegmentResponse
	err3 := proto.Unmarshal(reply.Data, &dd)
	if err3 != nil {
		log.Error(err3.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	handlerSpan.End()

	return connect.NewResponse(&dd), nil

}

func (s *DecisionServiceHandler) OptOut(ctx context.Context, req *connect.Request[advertisementv1pb.OptOutRequest]) (*connect.Response[advertisementv1pb.OptOutResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer
	log := *zaploggerv1.Bound.Logger

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Spec Propagation
	specCtx, specSpan := tracer.Start(validationCtx, "spec-propagation", trace.WithSpanKind(trace.SpanKindInternal))
	spec, ok := ctx.Value(sdkv2alphalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}
	specSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&advertisementv1pb.OptOutResponse{}) {
			log.Error("Invalid field mask")
			return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(specCtx, "event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	entity := advertisementv1pbmodel.DecisionSpecEntity{}
	reply, err2 := natsnodev1.Bound.MultiplexEventSync(handlerCtx, spec, &natsnodev1.SpecEvent{
		Request:        req.Msg,
		Stream:         natsnodev1.NewInboundStream(),
		EventName:      "",
		EventTopic:     advertisementv1pbmodel.EventDataDecisionTopic,
		EntityTypeName: entity.TypeName(),
	})
	if err2 != nil {
		log.Error(err2.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	var dd advertisementv1pb.OptOutResponse
	err3 := proto.Unmarshal(reply.Data, &dd)
	if err3 != nil {
		log.Error(err3.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	handlerSpan.End()

	return connect.NewResponse(&dd), nil

}

func (s *DecisionServiceHandler) Read(ctx context.Context, req *connect.Request[advertisementv1pb.ReadRequest]) (*connect.Response[advertisementv1pb.ReadResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer
	log := *zaploggerv1.Bound.Logger

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Spec Propagation
	specCtx, specSpan := tracer.Start(validationCtx, "spec-propagation", trace.WithSpanKind(trace.SpanKindInternal))
	spec, ok := ctx.Value(sdkv2alphalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}
	specSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&advertisementv1pb.ReadResponse{}) {
			log.Error("Invalid field mask")
			return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(specCtx, "event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	entity := advertisementv1pbmodel.DecisionSpecEntity{}
	reply, err2 := natsnodev1.Bound.MultiplexEventSync(handlerCtx, spec, &natsnodev1.SpecEvent{
		Request:        req.Msg,
		Stream:         natsnodev1.NewInboundStream(),
		EventName:      "",
		EventTopic:     advertisementv1pbmodel.EventDataDecisionTopic,
		EntityTypeName: entity.TypeName(),
	})
	if err2 != nil {
		log.Error(err2.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	var dd advertisementv1pb.ReadResponse
	err3 := proto.Unmarshal(reply.Data, &dd)
	if err3 != nil {
		log.Error(err3.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	handlerSpan.End()

	return connect.NewResponse(&dd), nil

}

func (s *DecisionServiceHandler) IpOverride(ctx context.Context, req *connect.Request[advertisementv1pb.IpOverrideRequest]) (*connect.Response[advertisementv1pb.IpOverrideResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer
	log := *zaploggerv1.Bound.Logger

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Spec Propagation
	specCtx, specSpan := tracer.Start(validationCtx, "spec-propagation", trace.WithSpanKind(trace.SpanKindInternal))
	spec, ok := ctx.Value(sdkv2alphalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}
	specSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&advertisementv1pb.IpOverrideResponse{}) {
			log.Error("Invalid field mask")
			return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(specCtx, "event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	entity := advertisementv1pbmodel.DecisionSpecEntity{}
	reply, err2 := natsnodev1.Bound.MultiplexEventSync(handlerCtx, spec, &natsnodev1.SpecEvent{
		Request:        req.Msg,
		Stream:         natsnodev1.NewInboundStream(),
		EventName:      "",
		EventTopic:     advertisementv1pbmodel.EventDataDecisionTopic,
		EntityTypeName: entity.TypeName(),
	})
	if err2 != nil {
		log.Error(err2.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	var dd advertisementv1pb.IpOverrideResponse
	err3 := proto.Unmarshal(reply.Data, &dd)
	if err3 != nil {
		log.Error(err3.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	handlerSpan.End()

	return connect.NewResponse(&dd), nil

}

func (s *DecisionServiceHandler) MatchUser(ctx context.Context, req *connect.Request[advertisementv1pb.MatchUserRequest]) (*connect.Response[advertisementv1pb.MatchUserResponse], error) {

	tracer := *opentelemetryv1.Bound.Tracer
	log := *zaploggerv1.Bound.Logger

	// Executes top level validation, no business domain validation
	validationCtx, validationSpan := tracer.Start(ctx, "request-validation", trace.WithSpanKind(trace.SpanKindInternal))
	v := *protovalidatev0.Bound.Validator
	if err := v.Validate(req.Msg); err != nil {
		return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(err)
	}
	validationSpan.End()

	// Spec Propagation
	specCtx, specSpan := tracer.Start(validationCtx, "spec-propagation", trace.WithSpanKind(trace.SpanKindInternal))
	spec, ok := ctx.Value(sdkv2alphalib.SpecContextKey).(*specv2pb.Spec)
	if !ok {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("Cannot propagate spec to context"))
	}
	specSpan.End()

	// Validate field mask
	if spec.SpecData.FieldMask != nil && len(spec.SpecData.FieldMask.Paths) > 0 {
		spec.SpecData.FieldMask.Normalize()
		if !spec.SpecData.FieldMask.IsValid(&advertisementv1pb.MatchUserResponse{}) {
			log.Error("Invalid field mask")
			return nil, sdkv2alphalib.ErrServerPreconditionFailed.WithInternalErrorDetail(errors.New("Invalid field mask"))
		}
	}

	// Distributed Domain Handler
	handlerCtx, handlerSpan := tracer.Start(specCtx, "event-generation", trace.WithSpanKind(trace.SpanKindInternal))

	entity := advertisementv1pbmodel.DecisionSpecEntity{}
	reply, err2 := natsnodev1.Bound.MultiplexEventSync(handlerCtx, spec, &natsnodev1.SpecEvent{
		Request:        req.Msg,
		Stream:         natsnodev1.NewInboundStream(),
		EventName:      "",
		EventTopic:     advertisementv1pbmodel.EventDataDecisionTopic,
		EntityTypeName: entity.TypeName(),
	})
	if err2 != nil {
		log.Error(err2.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	var dd advertisementv1pb.MatchUserResponse
	err3 := proto.Unmarshal(reply.Data, &dd)
	if err3 != nil {
		log.Error(err3.Error())
		return nil, connect.NewError(connect.CodeInternal, errors.New("internal error"))
	}

	handlerSpan.End()

	return connect.NewResponse(&dd), nil

}
