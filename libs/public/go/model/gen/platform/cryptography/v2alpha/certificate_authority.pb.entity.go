// Code generated by protoc-gen-platform go/entity-unspecified. DO NOT EDIT.
// source: platform/cryptography/v2alpha/certificate_authority.proto

package cryptographyv2alphapbmodel

import (
	"context"
	"encoding/json"

	"errors"
	"github.com/segmentio/ksuid"
	"google.golang.org/protobuf/types/known/anypb"
	"libs/public/go/protobuf/gen/platform/cryptography/v2alpha"
	"libs/public/go/sdk/v2alpha"

	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	specv2pb "libs/protobuf/go/protobuf/gen/platform/spec/v2"
	typev2pb "libs/protobuf/go/protobuf/gen/platform/type/v2"
)

type CertificateAuthoritySpecEntity struct {
	CertificateAuthority *cryptographyv2alphapb.CertificateAuthority
}

func NewCertificateAuthoritySpecEntity(specContext *specv2pb.SpecContext) (*CertificateAuthoritySpecEntity, error) {

	id := ksuid.New()
	createdAt := timestamppb.Now()

	return &CertificateAuthoritySpecEntity{
		CertificateAuthority: &cryptographyv2alphapb.CertificateAuthority{
			Id:        id.String(),
			CreatedAt: createdAt,
			UpdatedAt: createdAt,
		},
	}, nil

}

func NewCertificateAuthoritySpecEntityFromSpec(ctx context.Context, s *specv2pb.Spec) (*CertificateAuthoritySpecEntity, error) {
	data := &cryptographyv2alphapb.CertificateAuthority{}
	err := sdkv2alphalib.GetDataFromSpec[*cryptographyv2alphapb.CertificateAuthority](ctx, s, data)
	if err != nil {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(err)
	}

	return &CertificateAuthoritySpecEntity{
		CertificateAuthority: data,
	}, nil
}

func (entity *CertificateAuthoritySpecEntity) ToProto() (*cryptographyv2alphapb.CertificateAuthority, error) {

	return entity.CertificateAuthority, nil

}

func (entity *CertificateAuthoritySpecEntity) ToEvent() (*string, error) {

	bytes, err := json.Marshal(entity)
	if err != nil {
		return nil, err
	}

	event := string(bytes)

	return &event, nil

}

func (entity *CertificateAuthoritySpecEntity) FromEvent(event *string) (*CertificateAuthoritySpecEntity, error) {

	bytes := []byte(*event)
	err := json.Unmarshal(bytes, entity)
	if err != nil {
		return nil, err
	}

	return entity, nil

}

func (entity *CertificateAuthoritySpecEntity) MarshalEntity() (*anypb.Any, error) {

	d, err := anypb.New(entity.CertificateAuthority)
	if err != nil {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("failed to marshall entity"), err)
	}

	return d, nil

}

func (entity *CertificateAuthoritySpecEntity) MarshalProto() (*anypb.Any, error) {

	proto, err := entity.ToProto()
	if err != nil {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("failed to convert entity to proto"), err)
	}

	d, err := anypb.New(proto)
	if err != nil {
		return nil, sdkv2alphalib.ErrServerInternal.WithInternalErrorDetail(errors.New("failed to marshall proto"), err)
	}

	return d, nil

}

func (entity *CertificateAuthoritySpecEntity) TypeName() string {
	return "certificateAuthority"
}

func (entity *CertificateAuthoritySpecEntity) CommandTopic() string {
	return CommandDataCertificateAuthorityTopic
}

func (entity *CertificateAuthoritySpecEntity) EventTopic() string {
	return EventDataCertificateAuthorityTopic
}

func (entity *CertificateAuthoritySpecEntity) RoutineTopic() string {
	return RoutineDataCertificateAuthorityTopic
}

func (entity *CertificateAuthoritySpecEntity) TopicWildcard() string {
	return CertificateAuthorityTypeNameEventPrefix + ">"
}

func (entity *CertificateAuthoritySpecEntity) SystemName() string {
	return "cryptography"
}

func (entity *CertificateAuthoritySpecEntity) internal() {

	var _ timestamppb.Timestamp
	//created_at

	var _ timestamppb.Timestamp
	//updated_at

	var _ *cryptographyv2alphapb.Curve
	var _ durationpb.Duration

	//duration

	var _ *typev2pb.File
	var _ *typev2pb.File
	var _ *typev2pb.File
}
